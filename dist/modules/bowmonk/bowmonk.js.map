{"version":3,"sources":["../../../src/modules/bowmonk/bowmonk.ts"],"sourcesContent":["\r\nimport { SerialPort } from 'serialport'\r\nimport { log as bowmonkLog } from \"@utils/logger\";\r\n\r\nimport {ambientTemperature} from \"@modules/vaisala/vaisala\"\r\nimport {gpsPortState, currentGPSData} from \"@modules/gps/gps\"\r\n\r\n\r\nimport { BOWMONK_PORT, BOWMONK_BAUDRATE, BOWMONK_COMMAND_PAUSE, BOWMONK_TIMEOUT, INVALID_FRICTION } from \"@config\";\r\n\r\nconst UNSET_VALUE = -1;\r\n\r\nlet serialPort = null;\r\nlet socketIO = null;\r\n\r\nlet bowmonkReadings = [];\r\n\r\nconst BOWMONK_PREFIX = '!0000';\r\n\r\nconst COMMAND_READ_MEMORY  = '1';\r\nconst COMMAND_REARM_SYSTEM = 'A';\r\nconst COMMAND_RESET_SYSTEM = 'B';\r\n\r\nconst RAM_BASE_ADDRESS = 263;\r\n\r\nconst COMMAND_ERROR = 'Command Error: ';\r\n\r\nlet bowmonkPortState = false;\r\n\r\nlet acquiringBowmonkReading = false;\r\n\r\nlet bowmonkArmed = false;\r\nlet bowmonkReadingAvailable = false;\r\n\r\nlet flags = []\r\nlet mean;\r\nlet peak;\r\n\r\n\r\n\r\nfunction log (message)\r\n{\r\n    bowmonkLog('bowmonk > ' + message);\r\n}\r\n\r\nfunction setBowmonkPortState (state)\r\n{\r\n    bowmonkPortState = state;\r\n}\r\n\r\n\r\nfunction bowmonkPortSetup(serverSocketIO)\r\n{\r\n\r\n    // setup port\r\n    try {\r\n\r\n      log('Opening bowmonk port: ' + BOWMONK_PORT + ' @ baudrate: ' + BOWMONK_BAUDRATE);\r\n\r\n      serialPort = new SerialPort({path: BOWMONK_PORT, baudRate: BOWMONK_BAUDRATE, autoOpen: false, })\r\n      socketIO = serverSocketIO;\r\n\r\n      serialPort.on('data', bowmonkDataReceived); // continual data goes here, command data uses its own listener\r\n\r\n      serialPort.on('error', function(error) {\r\n        log('Error on bowmonk port - ' + error.message);\r\n      })\r\n\r\n      // open the port\r\n      serialPort.open(function (error) {\r\n\r\n        if (error) {\r\n            setBowmonkPortState(false);\r\n            log('Error opening bowmonk port: ' + error.message);\r\n        }\r\n        else {\r\n            setBowmonkPortState(true);\r\n            log('bowmonk port opened');\r\n\r\n            // continually watch for available bowmonk readings\r\n            setInterval (() => {\r\n\r\n              if (bowmonkReadingAvailable === true) {\r\n                  log('Bowmonk reading available');\r\n                  lookForBowmonkReading();\r\n              }\r\n\r\n            }, 500);\r\n\r\n\r\n        }\r\n      })\r\n\r\n    }\r\n    catch (error) {\r\n      log('Error opening bowmonk port - Error: ' + error);\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\nfunction bowmonkDataReceived (bowmonkDataString)\r\n{\r\n\r\n    try {\r\n\r\n      if (bowmonkDataString.includes('#') == true) {\r\n          bowmonkArmed = false;\r\n          bowmonkReadingAvailable = true;\r\n      }\r\n\r\n      if (bowmonkDataString.includes('*') == true) {\r\n          bowmonkReadingAvailable = false;\r\n          bowmonkArmed = true;\r\n          console.log('*');\r\n      }\r\n\r\n    }\r\n    catch (error) {\r\n      log (\"Bowmonk port reading error: \" + error);\r\n      bowmonkReadingAvailable = false;\r\n      bowmonkArmed = false;\r\n    }\r\n\r\n    // send out bowmonk status\r\n    const bowmonkStatus = {initialized: bowmonkPortState, armed: bowmonkArmed, readingAvailable: bowmonkReadingAvailable };\r\n\r\n    if (bowmonkPortState === true)\r\n        socketIO.emit('bowmonk', bowmonkStatus)\r\n\r\n};\r\n\r\n\r\n\r\n\r\nasync function sendCommand (bowmonkCommand): Promise<string>\r\n{\r\n\r\n  await serialPort.flush();\r\n\r\n  return new Promise(function(resolve, reject) {\r\n\r\n    let responseData = '';\r\n\r\n    // after BOWMONK_TIMEOUT msec, timeout and reject\r\n    const sendTimeout = setTimeout(() => {\r\n      removeTemporaryListeners();\r\n      reject(COMMAND_ERROR + 'timeout');\r\n    }, BOWMONK_TIMEOUT);\r\n\r\n    // handle any errors during port communications\r\n    const errorHandler = (error) => {\r\n      removeTemporaryListeners();\r\n      reject(COMMAND_ERROR + error);\r\n    };\r\n\r\n    // handle any data received from command\r\n    const dataHandler = (data) => {\r\n\r\n      responseData += data.toString();\r\n\r\n      if (responseData.includes('\\r')) {\r\n          // console.log('dataHandler(): ' + responseData);\r\n          clearTimeout(sendTimeout); // clear the timeout when data is received\r\n          removeTemporaryListeners();\r\n          resolve(responseData);\r\n      }\r\n    };\r\n\r\n    // remove added listeners once the promise is resolved/rejected\r\n    const removeTemporaryListeners = () => {\r\n      serialPort.removeListener('data', dataHandler);\r\n      serialPort.removeListener('error', errorHandler);\r\n    };\r\n\r\n    // add data handlers for this command\r\n    serialPort.on('data', dataHandler);\r\n    serialPort.on('error', errorHandler);\r\n\r\n    // write the command\r\n    serialPort.write(bowmonkCommand, (error) => {\r\n      if (error) {\r\n          removeTemporaryListeners();\r\n          reject(COMMAND_ERROR + error);\r\n      }\r\n    })\r\n\r\n\r\n  });\r\n\r\n}\r\n\r\n\r\n\r\nasync function sendCommand_ReadMemoryFromRAMBase (offset): Promise<string>\r\n{\r\n\r\n    const address = RAM_BASE_ADDRESS + offset;\r\n    const bowmonkCommand = BOWMONK_PREFIX + COMMAND_READ_MEMORY + address.toString(16).toUpperCase().padStart(4, 0) + '\\r';\r\n\r\n    const commandResponse = await sendCommand(bowmonkCommand);\r\n\r\n   return (commandResponse);\r\n}\r\n\r\n\r\nasync function GetNextTestNumber(): Promise<number>\r\n{\r\n\r\n        let nextTestNumber = UNSET_VALUE;\r\n\r\n        const commandResponse = await sendCommand_ReadMemoryFromRAMBase(0);\r\n\r\n        if (commandResponse.includes(COMMAND_ERROR) === false) {\r\n\r\n            if (commandResponse.length == 0)\r\n                return (UNSET_VALUE);\r\n\r\n            if ((commandResponse.length != 76) && (commandResponse.length != 77))\r\n                return (UNSET_VALUE);\r\n\r\n            if (commandResponse.substring(0, 6).toLowerCase().includes(\":31a01\") == false)\r\n                return (UNSET_VALUE);\r\n\r\n            try {\r\n\r\n              nextTestNumber = parseInt(commandResponse.substring(12,12+2), 16);\r\n\r\n            }\r\n            catch {\r\n              nextTestNumber = UNSET_VALUE;\r\n            }\r\n\r\n        }\r\n\r\n       return (nextTestNumber);\r\n}\r\n\r\n\r\nasync function pressAcceptKey (showMsg): Promise<boolean>\r\n{\r\n\r\n    let acceptKeySucessful = false;\r\n\r\n    const bowmonkCommand = BOWMONK_PREFIX + COMMAND_REARM_SYSTEM + \"\\r\";\r\n\r\n    const commandResponse = await sendCommand(bowmonkCommand);\r\n    if (commandResponse.includes(COMMAND_ERROR) === false) {\r\n\r\n        acceptKeySucessful = commandResponse.toLowerCase().includes(\":31a0a\");\r\n        if ((showMsg == true) && (acceptKeySucessful == false))\r\n            console.log(\"Unsuccessful Accept Key: \" + commandResponse);\r\n    }\r\n    else\r\n        console.log(\"Unsuccessful Accept Key: \" + commandResponse);\r\n\r\n    return (acceptKeySucessful);\r\n\r\n}\r\n\r\n\r\nasync function getTestDataAddressNumber (testNumber): Promise<number>\r\n{\r\n\r\n        let dataAddress = UNSET_VALUE;\r\n\r\n        const commandResponse = await sendCommand_ReadMemoryFromRAMBase(testNumber);\r\n        if (commandResponse.includes(COMMAND_ERROR) === false) {\r\n\r\n            if (commandResponse.length == 0)\r\n                return (UNSET_VALUE);\r\n\r\n            if ((commandResponse.length != 76) && (commandResponse.length != 77))\r\n                return (UNSET_VALUE);\r\n\r\n            if (commandResponse.substring(0, 6).toLowerCase().includes(\":31a01\") == false)\r\n                return (UNSET_VALUE);\r\n\r\n            try {\r\n\r\n              const firstByte = parseInt(commandResponse.substring(10,10+2), 16);\r\n              const secondByte = parseInt(commandResponse.substring(12,12+2), 16);\r\n\r\n              dataAddress = (firstByte * 256) + secondByte;\r\n\r\n            }\r\n            catch {\r\n              dataAddress = UNSET_VALUE;\r\n            }\r\n\r\n\r\n        }\r\n\r\n       return (dataAddress);\r\n}\r\n\r\n\r\nasync function getBowmonkTestData (testDataAddress): Promise<boolean>\r\n{\r\n\r\n      let readSucessful = true;\r\n\r\n      const bowmonkCommand = BOWMONK_PREFIX + COMMAND_READ_MEMORY + testDataAddress.toString(16).toUpperCase().padStart(4, 0) + \"\\r\";\r\n\r\n      const commandResponse = await sendCommand(bowmonkCommand);\r\n      if (commandResponse.includes(COMMAND_ERROR) === false) {\r\n\r\n          if (commandResponse.length == 0)\r\n              return (false);\r\n\r\n          if ((commandResponse.length != 76) && (commandResponse.length != 77))\r\n              return (false);\r\n\r\n          if (commandResponse.substring(0, 6).toLowerCase().includes(\":31a01\") == false)\r\n              return (false);\r\n\r\n          try {\r\n\r\n            // flags, instrument settings\r\n            flags = [];\r\n            flags.push(parseInt(commandResponse.substring(12,12+2), 16));\r\n            flags.push(parseInt(commandResponse.substring(10,10+2), 16));\r\n            flags.push(parseInt(commandResponse.substring(16,16+2), 16));\r\n            flags.push(parseInt(commandResponse.substring(14,14+2), 16));\r\n\r\n            // mean deceleration\r\n            let firstByte  = parseInt(commandResponse.substring(46,46+2), 16);\r\n            let secondByte = parseInt(commandResponse.substring(48,48+2), 16);\r\n            mean = ((firstByte * 256) + secondByte)/10.0;\r\n            mean /= 100;\r\n\r\n            // peak deceleration\r\n            firstByte  = parseInt(commandResponse.substring(42,42+2), 16);\r\n            secondByte = parseInt(commandResponse.substring(44,44+2), 16);\r\n            peak = ((firstByte * 256) + secondByte)/10.0;\r\n            peak /= 100;\r\n\r\n            // speed\r\n            //firstByte  = parseInt(dataResult.substring(50,2), 16);\r\n            //secondByte = parseInt(dataResult.substring(52,2), 16);\r\n            //speed = ((firstByte * 256) + secondByte)/10.0;\r\n\r\n            // date\r\n            ////Day   = parseInt(dataResult.substring(22,2), 16);\r\n            ////Month = parseInt(dataResult.substring(28,2), 16);\r\n            ////Year  = parseInt(dataResult.substring(26,2), 16);\r\n\r\n            ////Hour = parseInt(dataResult.substring(18,2), 16);\r\n            ////Minute = parseInt(dataResult.substring(20,2), 16);\r\n\r\n            ////ReadingTime = new Date(Year, Month, Day, Hour, Minute, 0);\r\n\r\n            readSucessful = true;\r\n\r\n          }\r\n          catch {\r\n            readSucessful = false;\r\n          }\r\n\r\n          // get runway ID\r\n          ////TestDataAddress += 32;\r\n          ////BowmonkCommand = BOWMONK_PREFIX + COMMAND_READ_MEMORY + TestDataAddress.ToString(\"X4\") + \"\\r\";\r\n          ////SendCommand(BowmonkCommand, 76);\r\n\r\n          ////DataResult = Get Data();\r\n\r\n          ////if (ReceiveTimeout == false) {\r\n\r\n          ////    try {\r\n\r\n          ////      Runway = \"\";\r\n          ////      for (i=0; i<16; i++) {\r\n\r\n          ////           if (i ==  0) n = 12;\r\n          ////           if (i ==  1) n = 10;\r\n          ////           if (i ==  2) n = 16;\r\n          ////           if (i ==  3) n = 14;\r\n          ////           if (i ==  4) n = 20;\r\n          ////           if (i ==  5) n = 18;\r\n          ////           if (i ==  6) n = 24;\r\n          ////           if (i ==  7) n = 22;\r\n          ////           if (i ==  8) n = 28;\r\n          ////           if (i ==  9) n = 26;\r\n          ////           if (i == 10) n = 32;\r\n          ////           if (i == 11) n = 30;\r\n          ////           if (i == 12) n = 36;\r\n          ////           if (i == 13) n = 34;\r\n          ////           if (i == 14) n = 40;\r\n          ////           if (i == 15) n = 38;\r\n\r\n          ////           Runway += (char)Int16.Parse(DataResult.Substring(n,2), 16);\r\n\r\n          ////      }\r\n\r\n          ////    }\r\n          ////    catch {\r\n          ////      Runway = \"Not set\";\r\n          ////      //ReadSucessful = false;\r\n          ////    }\r\n\r\n          ////}\r\n\r\n      }\r\n      else\r\n          readSucessful = false;\r\n\r\n    return (readSucessful);\r\n\r\n}\r\n\r\nfunction delay (delayMs)\r\n{\r\n  return new Promise(resolve => setTimeout(resolve, delayMs));\r\n}\r\n\r\nasync function lookForBowmonkReading()\r\n{\r\n\r\n\r\n    if (acquiringBowmonkReading === true)\r\n        return;\r\n\r\n    let acceptKeySucessful;\r\n\r\n    acquiringBowmonkReading = true;\r\n    bowmonkReadingAvailable = false;\r\n\r\n    try {\r\n\r\n      // press Accept key to get reading\r\n      acceptKeySucessful = await pressAcceptKey(true);\r\n\r\n      if (acceptKeySucessful == false) {\r\n\r\n          log (\"First Accept Key FAILED - Trying Again\");\r\n\r\n          await delay(BOWMONK_COMMAND_PAUSE);\r\n\r\n          acceptKeySucessful = await pressAcceptKey(true);\r\n\r\n          if (acceptKeySucessful === false)\r\n              log (\"1 Retry Accept Key FAILED\");\r\n          //else\r\n          //    console.log (\"1 Retry Accept Key - SUCCESS\");\r\n\r\n      }\r\n      //else\r\n      //    log (\"First Accept Key - SUCCESS\");\r\n\r\n\r\n      await delay(BOWMONK_COMMAND_PAUSE);\r\n\r\n      // get test number\r\n      let nextTestNumber = await GetNextTestNumber();\r\n      if (nextTestNumber === UNSET_VALUE) { // try again if first attempt failed\r\n          log(\"getNextTestNumber() Failed - Trying Again\");\r\n          await delay(BOWMONK_COMMAND_PAUSE);\r\n          nextTestNumber = await GetNextTestNumber();\r\n      }\r\n\r\n      // if valid test number obtained\r\n      if (nextTestNumber !== UNSET_VALUE) {\r\n\r\n          const testNumber = nextTestNumber - 1; // read the last test, which is the next test number minus 1\r\n          // log (\"Reading Test #: \" + testNumber);\r\n\r\n          await delay(BOWMONK_COMMAND_PAUSE);\r\n\r\n          // get test data address\r\n          let testDataAddress = await getTestDataAddressNumber(testNumber);\r\n          if (testDataAddress === UNSET_VALUE) {\r\n              log(\"getTestDataAddressNumber() Failed - Trying Again\");\r\n              await delay(BOWMONK_COMMAND_PAUSE);\r\n              testDataAddress = await getTestDataAddressNumber(testNumber);\r\n          }\r\n\r\n          // if valid test data address obtained\r\n          if (testDataAddress !== UNSET_VALUE) {\r\n\r\n              await delay(BOWMONK_COMMAND_PAUSE);\r\n\r\n              // get test data\r\n              let testDataObtained = await getBowmonkTestData(testDataAddress);\r\n              if (testDataObtained === false) {\r\n                  log(\"getBowmonkTestData() Failed - Trying Again\");\r\n                  await delay(BOWMONK_COMMAND_PAUSE);\r\n                  testDataObtained = await getBowmonkTestData(testDataAddress);\r\n              }\r\n\r\n              // test data received successfully\r\n              if (testDataObtained === true) {\r\n\r\n                  // log (\"Mean: \" + mean);\r\n                  // log (\"Peak: \" + peak);\r\n                  // log (\"Speed: \" + Bowmonk.Speed);\r\n                  // log (\"Flags: 1 - \" + Bowmonk.Flags[0] + \" 2 - \" + Bowmonk.Flags[1] + \" 3 - \" + Bowmonk.Flags[2] + \" 4 - \" + Bowmonk.Flags[3]);\r\n\r\n\r\n                  // only create record if reading is within valid range\r\n                  if ((peak >= .01) && (peak <= .99)) {\r\n\r\n                      // create rsc location record\r\n                      if ((gpsPortState === true) && (currentGPSData.valid === true)) {\r\n\r\n                          const bowmonkReading = {readingTime: currentGPSData.timedate, latitude: currentGPSData.latitude, longitude: currentGPSData.longitude, friction: peak, ambient: ambientTemperature};\r\n\r\n                          bowmonkReadings.push(bowmonkReading);\r\n                          log ('Pushing: ' + JSON.stringify(bowmonkReading));\r\n                      }\r\n                      else\r\n                          log ('GPS reading unavailable - Port Open: ' + gpsPortState + ', valid: ' + currentGPSData.valid);\r\n                  }\r\n                  else\r\n                    log (\"Reading Outside Range: \" + peak);\r\n\r\n              }\r\n              else\r\n                log (\"getBowmonkTestData() Failed\");\r\n\r\n          }\r\n          else\r\n            log (\"Could Not Get Test Data Address\");\r\n\r\n      }\r\n      else\r\n        log (\"Could Not Get Next Test Number\");\r\n\r\n\r\n      // press Accept key again to re-arm for next reading\r\n      await delay(BOWMONK_COMMAND_PAUSE);\r\n\r\n      acceptKeySucessful = await pressAcceptKey(true);\r\n      if (acceptKeySucessful == false) {\r\n\r\n          log (\"Second Accept Key FAILED - Trying Again\");\r\n          acceptKeySucessful = await pressAcceptKey(true);\r\n          acceptKeySucessful = pressAcceptKey(true);\r\n\r\n          if (acceptKeySucessful == false)\r\n              log (\"2 Retry Accept Key FAILED\");\r\n          //else\r\n          //    log (\"2 Retry Accept Key - SUCCESS\");\r\n\r\n      }\r\n      //else\r\n      //    log (\"Second Accept Key - SUCCESS\");\r\n\r\n\r\n      // extra Accept key, for good luck\r\n      // acceptKeySucessful = await pressAcceptKey(true);\r\n      // if (acceptKeySucessful == true)\r\n      //     log (\"Extra Accept Key SUCCESS\");\r\n\r\n\r\n      // clear COM buffers and pause\r\n      // await delay(BOWMONK_COMMAND_PAUSE);\r\n      // serialPort.flush();\r\n\r\n    }\r\n    catch (error) {\r\n\r\n       log (\"lookForBowmonkReading() Error: \" + error);\r\n\r\n    }\r\n    finally {\r\n\r\n      acquiringBowmonkReading = false;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\nexport {bowmonkPortState, bowmonkPortSetup, bowmonkReadings};"],"names":["bowmonkPortState","bowmonkPortSetup","bowmonkReadings","UNSET_VALUE","serialPort","socketIO","BOWMONK_PREFIX","COMMAND_READ_MEMORY","COMMAND_REARM_SYSTEM","COMMAND_RESET_SYSTEM","RAM_BASE_ADDRESS","COMMAND_ERROR","acquiringBowmonkReading","bowmonkArmed","bowmonkReadingAvailable","flags","mean","peak","log","message","bowmonkLog","setBowmonkPortState","state","serverSocketIO","BOWMONK_PORT","BOWMONK_BAUDRATE","SerialPort","path","baudRate","autoOpen","on","bowmonkDataReceived","error","open","setInterval","lookForBowmonkReading","bowmonkDataString","includes","console","bowmonkStatus","initialized","armed","readingAvailable","emit","sendCommand","bowmonkCommand","flush","Promise","resolve","reject","responseData","sendTimeout","setTimeout","removeTemporaryListeners","BOWMONK_TIMEOUT","errorHandler","dataHandler","data","toString","clearTimeout","removeListener","write","sendCommand_ReadMemoryFromRAMBase","offset","address","commandResponse","toUpperCase","padStart","GetNextTestNumber","nextTestNumber","length","substring","toLowerCase","parseInt","pressAcceptKey","showMsg","acceptKeySucessful","getTestDataAddressNumber","testNumber","dataAddress","firstByte","secondByte","getBowmonkTestData","testDataAddress","readSucessful","push","delay","delayMs","testDataObtained","bowmonkReading","BOWMONK_COMMAND_PAUSE","gpsPortState","currentGPSData","valid","readingTime","timedate","latitude","longitude","friction","ambient","ambientTemperature","JSON","stringify"],"mappings":"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"}